通过执行函数控制期约状态 由于期约的状态是私有的，所以只能在内部进行操作。内部操作在 期约的执行器函数中完成。执行器函数主要有两项职责：初始化期 约的异步行为和控制状态的最终转换。其中，控制期约状态的转换 是通过调用它的两个函数参数实现的。这两个函数参数通常都命名 为 resolve()和 reject()。调用 resolve()会把状态切换为兑现，调 用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错 误（后面会讨论这个错误）。 let p1 = new Promise((resolve, reject) => resolve()); setTimeout(console.log, 0, p1); // Promise <resolved> let p2 = new Promise((resolve, reject) => reject()); setTimeout(console.log, 0, p2); // Promise <rejected> // Uncaught error (in promise) 在前面的例子中，并没有什么异步操作，因为在初始化期约时，执 行器函数已经改变了每个期约的状态。这里的关键在于，执行器函 数是同步执行的。这是因为执行器函数是期约的初始化程序。通过 下面的例子可以看出上面代码的执行顺序： new Promise(() => setTimeout(console.log, 0, 'executor')); setTimeout(console.log, 0, 'promise initialized'); // executor // promise initialized 添加 setTimeout 可以推迟切换状态： let p = new Promise((resolve, reject) => setTimeout(resolve, 1000)); // 在 console.log 打印期约实例的时候，还不会执行超时回调（即 resolve()） setTimeout(console.log, 0, p); // Promise <pending> 无论 resolve()和 reject()中的哪个被调用，状态转换都不可撤销 了。于是继续修改状态会静默失败，如下所示： let p = new Promise((resolve, reject) => { resolve(); reject(); // 没有效果 }); setTimeout(console.log, 0, p); // Promise <resolved> 为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可 以通过 setTimeout 设置一个 10 秒钟后无论如何都会拒绝期约的回 调： let p = new Promise((resolve, reject) => { setTimeout(reject, 10000); // 10 秒后调用 reject() // 执行函数的逻辑 }); setTimeout(console.log, 0, p); // Promise <pending> setTimeout(console.log, 11000, p); // 11 秒后再检查状态 // (After 10 seconds) Uncaught error // (After 11 seconds) Promise <rejected> 因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放 心地设置让期约处于待定状态的最长时间。如果执行器中的代码在 超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失 败。
