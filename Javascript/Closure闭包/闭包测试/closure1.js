function foo() {
    var a = 2;
  
    function bar() {
      console.log(a);
    }
  
    return bar;
  }
  
  var baz = foo();
  
  baz(); //2
  

// 代码执行流进入全局执行环境，并对全局执行环境中的代码进行声明提升。
// 执行流执行 var baz = foo ，调用 foo 函数，此时执行流进入 foo 执行环境中，对该执行环境中的代码进行声明提升过程。此时执行环境栈中存在两个执行环境，foo 函数为当前执行流所在执行环境。
// 执行流执行代码 var a = 2;，对 a 进行 LHS 查询，给 a 赋值 2。
// 执行流执行 return bar ，将 bar 函数作为返回值返回。按理说，这时 foo 函数已经执行完毕，应该销毁其执行环境，等待垃圾回收。但因为其返回值是 bar 函数。bar 函数中存在自由变量 a，需要通过作用域链到 foo 函数的执行环境中找到变量 a 的值，所以虽然 foo 函数的执行环境被销毁，但其变量对象不能被销毁，只是从活动状态变成非活动状态；而全局环境的变量对象则变成活动状态；执行流继续执行 var baz = foo，把 foo 函数的返回值 bar 函数赋值给 baz。
// 执行流执行 baz ，通过在全局执行环境中查找 baz 的值，baz 保存着 foo 函数的返回值 bar。所以这时执行 baz ，会调用 bar 函数，此时执行流进入 bar 函数执行环境中，对该执行环境中的代码进行声明提升过程。此时执行环境栈中存在三个执行环境，bar 函数为当前执行流所在的执行环境。
// 在声明提升的过程中，由于 a 是个自由变量，需要通过 bar 函数的作用域链 bar -> foo -> 全局作用域 进行查找，最终在 foo 函数中找到 var a = 2; ，然后在 foo 函数的执行环境中找到 a 的值是 2，所以给 a 赋值 2。
// 执行流执行 console.log(a) ，调用内部对象 console，并从 console 对象中找到 log 方法，将 a 作为参数传递进去。从 bar 函数的执行环境中找到 a 的值是 2，所以，最终在控制台显示 2。
// 执行流执行完 bar 函数后，bar 的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权还给全局执行环境。
// 当页面关闭时，所有执行环境都被销毁